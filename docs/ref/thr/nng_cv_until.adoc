## nng_cv_until

Wait for condition or timeout.

### Synopsis

```c
#include <nng/nng.h>
#include <nng/supplemental/util/platform.h>

int nng_cv_until(nng_cv *cv, nng_time when);
```

### Description

The `nng_cv_until` function waits until either the condition variable _cv_ is signaled by another thread calling either xref:nng_cv_wake.adoc[`nng_cv_wake`] or xref:nng_cv_wake1.adoc[`nng_cv_wake1`], or the system clock (as tracked by xref:nng_clock.adoc[`nng_clock`]) reaches _when_.

The caller must have have ownership of the mutex that was used when _cv_ was allocated.
This function will drop the ownership of that mutex, and reacquire it atomically just before returning to the caller.

NOTE: Any condition may be used or checked, but the condition must be checked, as it is possible for this function to wake up spuriously.
The idiomatic way to do this is inside a loop that repeats until the condition is true.

### Example

The following example demonstrates use of this function:

.Example 1: Waiting for the condition
```c
    expire = nng_clock() + 1000; // 1 second in the future
    nng_mtx_lock(m);  // assume cv was allocated using m
    while (!condition_true) {
        if (nng_cv_until(cv, expire) == NNG_ETIMEDOUT) {
            printf("Time out reached!\n");
            break;
        }
    }
    // condition_true is true
    nng_mtx_unlock(m);
```

.Example 2: Signaling the condition
```c
    nng_mtx_lock(m);
    condition_true = true;
    nng_cv_wake(cv);
    nng_mtx_unlock(m);
```

### See Also

xref:nng_cv_wait.adoc[nng_cv_wait],
xref:nng_cv_wake.adoc[nng_cv_wake],
xref:nng_cv_wake1.adoc[nng_cv_wake1],
xref:nng_mtx_lock.adoc[nng_mtx_lock]
